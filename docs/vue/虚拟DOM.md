# 虚拟 DOM

## 什么是虚拟 DOM

虚拟 DOM 是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上

在 Javascript 对象中，虚拟 DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别

## 为什么需要虚拟 DOM

- DOM 是很慢的，其元素非常庞大，页面的性能问题，大部分都是由 DOM 操作引起的，操作 DOM 的代价是昂贵的，频繁操作会出现页面卡顿，影响用户的体验
- 虚拟 DOM 不会立即操作 DOM，而是将更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算
- 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI

## 虚拟 DOM 有什么坏处？

- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。
- 需要额外的创建函数，如 createElement 或 h，但可以通过 JSX 或者 vue-loader 来简化成 XML 写法。但是这么做会依赖打包工具。

## vue 对 虚拟 dom 的优化

- nextTick()
- patch 算法
  当新的 VNode 与旧的 oldVNode 都是元素节点并且都包含子节点时，那么这两个节点的 VNode 实例上的 children 属性就是所包含的子节点数组。我们把新的 VNode 上的子节点数组记为 newChildren，把旧的 oldVNode 上的子节点数组记为 oldChildren。

同样是有四种情况：

- 创建子节点：如果 newChildren 里面的某个子节点在 oldChildren 里找不到与之相同的子节点，那么说明 newChildren 里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。
- 删除子节点：如果把 newChildren 里面的每一个子节点都循环完毕后，发现在 oldChildren 还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。
- 移动子节点：如果 newChildren 里面的某个子节点在 oldChildren 里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置，使之与在 newChildren 里的位置相同。
- 更新节点：如果 newChildren 里面的某个子节点在 oldChildren 里找到了与之相同的子节点，并且所处的位置也相同，那么就更新 oldChildren 里该节点，使之与 newChildren 里的该节点相同。

外层循环新节点的 children 数组，内层循环旧节点的 children 数组，每循环外层的新节点的 children 数组中的一个子节点，就去内层老节点的 children 数组中去找有没有相同的节点，再根据不同的情况去做操作。当包含的子节点数量过多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。

优化：

- 先把 newChildren 数组里的所有**未处理**子节点的**第一个子节点**和 oldChildren 数组里所有**未处理**子节点的**第一个子节点**做比对，如果相同，那就直接进入更新节点的操作；
- 如果不同，再把 newChildren 数组里所有**未处理**子节点的**最后一个子节点**和 oldChildren 数组里所有**未处**理子节点的**最后一个子节点**做比对，如果相同，那就直接进入更新节点的操作；
- 如果不同，再把 newChildren 数组里所有**未处理**子节点的**最后一个子节点**和 oldChildren 数组里所有**未处理**子节点的**第一个子节点**做比对，如果相同，那就直接进入更新节点的操作，更新完后再将 oldChildren 数组里的该节点移动到与 newChildren 数组里节点相同的位置；
- 如果不同，再把 newChildren 数组里所有**未处理**子节点的**第一个子节点**和 oldChildren 数组里所有**未处理**子节点的**最后一个子节点**做比对，如果相同，那就直接进入更新节点的操作，更新完后再将 oldChildren 数组里的该节点移动到与 newChildren 数组里节点相同的位置；
- 最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。
